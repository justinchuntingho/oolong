{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Oolong Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotiln multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a Render function which is implemented by each frontend. Example Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg >) -> Unit , val decrement : ( Dispatch < Msg >) -> Unit ) val init : Init < Model , Msg > = { Model () to none () } val update : Update < Model , Msg > = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model + 1 ) Msg . Decrement -> model . copy ( count = model - 1 ) } to none () } val view : View < Model , Props > = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } Initialize an Oolong runtime by supplying your Init , Update , and View functions as well as a Render function from the host platform. val render : Render < Msg , Props > = { props , dispatch -> // Platform specific rendering countLabel . text = \"${props.count}\" incrementButton . setOnClickListener { props . increment ( dispatch ) } decrementButton . setOnClickListener { props . decrement ( dispatch ) } } val dispose = Oolong . runtime ( init , update , view , render )","title":"Overview"},{"location":"#oolong","text":"Oolong is an Elm inspired Model-View-Update (MVU) implementation for Kotiln multiplatform. As the name implies, three core concepts comprise the foundation of this architecture: Model - a type to represent the program state View - a function to map the state to view properties Update - a function to update the state By applying this simple pattern you can create composable, testable programs that can run on any platform. Oolong enables a common codebase for all platforms by using a Render function which is implemented by each frontend.","title":"Oolong"},{"location":"#example","text":"Here is a simple example in which a number can be incremented or decremented. data class Model ( val count : Int = 0 ) sealed class Msg { object Increment : Msg () object Decrement : Msg () } class Props ( val count : Int , val increment : ( Dispatch < Msg >) -> Unit , val decrement : ( Dispatch < Msg >) -> Unit ) val init : Init < Model , Msg > = { Model () to none () } val update : Update < Model , Msg > = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model + 1 ) Msg . Decrement -> model . copy ( count = model - 1 ) } to none () } val view : View < Model , Props > = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } Initialize an Oolong runtime by supplying your Init , Update , and View functions as well as a Render function from the host platform. val render : Render < Msg , Props > = { props , dispatch -> // Platform specific rendering countLabel . text = \"${props.count}\" incrementButton . setOnClickListener { props . increment ( dispatch ) } decrementButton . setOnClickListener { props . decrement ( dispatch ) } } val dispose = Oolong . runtime ( init , update , view , render )","title":"Example"},{"location":"changelog/","text":"Changelog Unreleased 2.0.6 - 2020-06-30 Fixed Maven Central artifacts. 2.0.5 - 2020-06-10 Added Update Kotlin Coroutines to 1.3.7 2.0.4 - 2020-05-17 Added Update Kotlin Coroutines to 1.3.6 Add samples link to readme Fixed Allow dispatcher specification. 2.0.3 - 2020-04-25 Added Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5 Removed Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function. 2.0.2 - 2020-01-08 Added Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3 Removed Samples moved to https://github.com/oolong-kt/oolong-samples 2.0.1 - 2019-06-20 Added Update Kotlin to 1.3.40 Changed Remove default arguments for Runtime constructor 2.0.0 - 2019-05-31 Added Add samples Changed Move to oolong-kt org and update packages Change core types from classes to functions 1.0.0 - 2018-08-01 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#206-2020-06-30","text":"","title":"2.0.6 - 2020-06-30"},{"location":"changelog/#fixed","text":"Maven Central artifacts.","title":"Fixed"},{"location":"changelog/#205-2020-06-10","text":"","title":"2.0.5 - 2020-06-10"},{"location":"changelog/#added","text":"Update Kotlin Coroutines to 1.3.7","title":"Added"},{"location":"changelog/#204-2020-05-17","text":"","title":"2.0.4 - 2020-05-17"},{"location":"changelog/#added_1","text":"Update Kotlin Coroutines to 1.3.6 Add samples link to readme","title":"Added"},{"location":"changelog/#fixed_1","text":"Allow dispatcher specification.","title":"Fixed"},{"location":"changelog/#203-2020-04-25","text":"","title":"2.0.3 - 2020-04-25"},{"location":"changelog/#added_2","text":"Update Kotlin to 1.3.72 Update Kotlin Coroutines to 1.3.5","title":"Added"},{"location":"changelog/#removed","text":"Deprecated coroutine scope and context arguments in runtime creator function. Remove deprecated runtime creator function.","title":"Removed"},{"location":"changelog/#202-2020-01-08","text":"","title":"2.0.2 - 2020-01-08"},{"location":"changelog/#added_3","text":"Update Kotlin to 1.3.61 Update Kotlin Coroutines to 1.3.3","title":"Added"},{"location":"changelog/#removed_1","text":"Samples moved to https://github.com/oolong-kt/oolong-samples","title":"Removed"},{"location":"changelog/#201-2019-06-20","text":"","title":"2.0.1 - 2019-06-20"},{"location":"changelog/#added_4","text":"Update Kotlin to 1.3.40","title":"Added"},{"location":"changelog/#changed","text":"Remove default arguments for Runtime constructor","title":"Changed"},{"location":"changelog/#200-2019-05-31","text":"","title":"2.0.0 - 2019-05-31"},{"location":"changelog/#added_5","text":"Add samples","title":"Added"},{"location":"changelog/#changed_1","text":"Move to oolong-kt org and update packages Change core types from classes to functions","title":"Changed"},{"location":"changelog/#100-2018-08-01","text":"Initial release","title":"1.0.0 - 2018-08-01"},{"location":"guide/core-concepts/","text":"Core Concepts Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model. Model The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 ) Update Messages Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed class. This allows us to use an exhaustive list of types when interpreting messages. sealed class Msg { object Increment : Msg () object Decrement : Msg () } Update function The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed classes. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : Update < Model , Msg > = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) to none () Msg . Decrement -> model . copy ( count = model . count - 1 ) to none () } } View The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props . View properties There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is message generators. Your rendering code will know how to display properties and dispatch messages created from generators. If you are only targetting one platform, then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : ( Dispatch < Msg >) -> Unit , val decrement : ( Dispatch < Msg >) -> Unit ) View function The view function, as mentioned above, takes the current state its argument and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : View < Model , Props > = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) } Putting it all together Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties. Initialization function To get the runtime loop started, we first need to know what the initial state is. We do this by definiting an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desireable to define defaults in the model class and simply return a new instance from the init function. val init : Init < Model , Msg > = { Model () to none () } Render function We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : Render < Msg , Props > = { props , dispatch -> // Platform specific rendering countLabel . text = \"${props.count}\" incrementButton . setOnClickListener { dispatch ( props . increment ()) } decrementButton . setOnClickListener { dispatch ( props . decrement ()) } } Runtime The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render )","title":"Core Concepts"},{"location":"guide/core-concepts/#core-concepts","text":"Let's visit each of the core concepts by examining a simple example. We'll create a simple \"counter\" program that can increment and decrement an Int state. In MVU architecture, state is changed by dispatching and handling messages. We'll look at this more in a moment. First let's take a look at the model.","title":"Core Concepts"},{"location":"guide/core-concepts/#model","text":"The model is a representation of the state of your application. In this case, the model contains just one property which is an Int named count with a default value of 0 . By convention, we define the model as a data class so it can be mutated easily. While your application is running, the model will be changing from one state to the next every time a message is dispatched. data class Model ( val count : Int = 0 )","title":"Model"},{"location":"guide/core-concepts/#update","text":"","title":"Update"},{"location":"guide/core-concepts/#messages","text":"Before looking at the update function, let's talk about messages. Messages describe the way we want the application state to change. In the case of our counter app, we have two messages that can be dispatched and handled: Increment and Decrement . Increment adds 1 to the current value of count and Decrement subtracts 1 from count . By convention, messages are defined as part of a sealed class. This allows us to use an exhaustive list of types when interpreting messages. sealed class Msg { object Increment : Msg () object Decrement : Msg () }","title":"Messages"},{"location":"guide/core-concepts/#update-function","text":"The update function uses these two concepts to take a previous state and transform it to the next state. When a message is dispatched, the update function is called with the dispatched message and the current state as arguments. The function must determine what state to return given these arguments. So far we have mentioned two conventions: models are data classes, and messages are sealed classes. You can see in the function below how those modifiers are leveraged. The message type is able to be determined in an exhaustive manner using the when block. The new state is created by mutating the old state with the copy function. val update : Update < Model , Msg > = { msg , model -> when ( msg ) { Msg . Increment -> model . copy ( count = model . count + 1 ) to none () Msg . Decrement -> model . copy ( count = model . count - 1 ) to none () } }","title":"Update function"},{"location":"guide/core-concepts/#view","text":"The job of the view function is to transform the current state into something that can be rendered in a UI. This could be an HTML string, a tree of widgets, or in multiplatform projects it will be a simple data structure. We call this output type view properties or Props .","title":"View"},{"location":"guide/core-concepts/#view-properties","text":"There are two types of data you may want to store in your view properties. First is information that you want to be rendered to the UI, and in this case we want to show the current count. The second category of data is message generators. Your rendering code will know how to display properties and dispatch messages created from generators. If you are only targetting one platform, then you may decide to return components specific to that platform, but since Oolong is a multiplatform library it is convention to use a hierarchical data structure. class Props ( val count : Int , val increment : ( Dispatch < Msg >) -> Unit , val decrement : ( Dispatch < Msg >) -> Unit )","title":"View properties"},{"location":"guide/core-concepts/#view-function","text":"The view function, as mentioned above, takes the current state its argument and returns view properties. In our counter example we populate the view properties with: count - the current count. increment - a function which dispatches the Increment message. decrement - a function which dispatches the Decrement message. val view : View < Model , Props > = { model -> Props ( model . count , { dispatch -> dispatch ( Msg . Increment ) }, { dispatch -> dispatch ( Msg . Decrement ) } ) }","title":"View function"},{"location":"guide/core-concepts/#putting-it-all-together","text":"Now that we've built the core components of our application we need a few more things to complete it, namely a way to create an initial application state and a way to render the view properties.","title":"Putting it all together"},{"location":"guide/core-concepts/#initialization-function","text":"To get the runtime loop started, we first need to know what the initial state is. We do this by definiting an initialization function. This function is similar to the update function, however it takes no arguments. By convention, it is often desireable to define defaults in the model class and simply return a new instance from the init function. val init : Init < Model , Msg > = { Model () to none () }","title":"Initialization function"},{"location":"guide/core-concepts/#render-function","text":"We also need to know how to render the view properties returned by the view function. Each target platform does this by implementing a render function which takes the view properties and a dispatch function as arguments. The dispatch function can be invoked to send messages to the update function. val render : Render < Msg , Props > = { props , dispatch -> // Platform specific rendering countLabel . text = \"${props.count}\" incrementButton . setOnClickListener { dispatch ( props . increment ()) } decrementButton . setOnClickListener { dispatch ( props . decrement ()) } }","title":"Render function"},{"location":"guide/core-concepts/#runtime","text":"The Oolong runtime composes these core functions into a user interaction loop, continually moving from one state to the next. It also handles things like side-effects (which we'll see in the next chapter) and resource disposal. You can start this loop by calling Oolong.runtime . val dispose = Oolong . runtime ( init , update , view , render )","title":"Runtime"},{"location":"guide/rendering/","text":"Rendering Coming soon!","title":"Rendering"},{"location":"guide/rendering/#rendering","text":"Coming soon!","title":"Rendering"},{"location":"guide/side-effects/","text":"Side Effects A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect < Msg > { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect < Msg > { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"guide/side-effects/#side-effects","text":"A side effect is an operation that modifies some state outside of the local environment. HTTP requests, disk I/O, user input, and dispalying pixels on a screen are examples of side effects. As you can imagine, a program without side effects is not very useful at all. Functional programming loves pure functions and abhors side effects, so how can we perform effectful operations while keeping our code pure? MVU uses the concept of managed effects . Instead of performing effects in your purely functional core, you describe the effect and pass it off to the runtime where it can be safely executed. In Oolong, for each call to update we return a Next value. This value is a Pair comprised of the new state and an Effect . After getting the next value, the effect is launched in a new coroutine away from the runtime. Looking at the type of Effect you'll notice it takes a single argument of type Dispatch . typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch<Msg>) -> Any? This is how you call back in to your purely functional code: by calling dispatch with an effect response message. Here's a simple example which dispatches a message after a short delay. val continueAfterDelayEffect = effect < Msg > { dispatch -> delay ( 500 ) dispatch ( Msg . Continue ) } In this example, they delay is a stand-in for any time consuming operation that you might do, for example an HTTP request. An actual network effect might look like this: val getNetworkItemsEffect = effect < Msg > { dispatch -> val response = itemNetworkRepository . getItems () val msg = when ( response ) { is Either . Left -> { Msg . GetNetworkItemsFailure ( response . value ) } is Either . Right -> { Msg . GetNetworkItemsSuccess ( response . value ) } } dispatch ( msg ) } For most updates, you may not want to perform any side effects. In this case you can just return an effect with an empty body or just use the provided none() function. At other times, you may want to return multiple effects. You can compose multiple effects using the batch() function. Oolong provides a few utility functions for common effects, which can be found in oolong.delay and oolong.random .","title":"Side Effects"},{"location":"oolong/","text":"oolong Packages Name Summary (common) oolong (common) oolong.delay (common) oolong.dispatch (common) oolong.effect (common) oolong.next (common) oolong.random Index All Types","title":"API Reference"},{"location":"oolong/#packages","text":"Name Summary (common) oolong (common) oolong.delay (common) oolong.dispatch (common) oolong.effect (common) oolong.next (common) oolong.random","title":"Packages"},{"location":"oolong/#index","text":"All Types","title":"Index"},{"location":"oolong/alltypes/","text":"All Types Name Summary (common) oolong.Dispatch Dispatches a message to the runtime |(common) oolong.Dispose Stops the function and cleans up resources |(common) oolong.Effect Runs a side-effect away from the runtime |(common) oolong.Init Creates an initial state and side-effects |(common) oolong.Next A pair of the next state and side-effects |(common) oolong.Oolong Oolong runtime module. |(common) oolong.Render Renders the view properties |(common) oolong.Update Creates a next state and side-effects from a message and current state |(common) oolong.View Creates view properties from the current state","title":"All Types - Oolong"},{"location":"oolong/alltypes/#all-types","text":"Name Summary (common)","title":"All Types"},{"location":"oolong/alltypes/#oolongdispatch","text":"Dispatches a message to the runtime |(common)","title":"oolong.Dispatch"},{"location":"oolong/alltypes/#oolongdispose","text":"Stops the function and cleans up resources |(common)","title":"oolong.Dispose"},{"location":"oolong/alltypes/#oolongeffect","text":"Runs a side-effect away from the runtime |(common)","title":"oolong.Effect"},{"location":"oolong/alltypes/#oolonginit","text":"Creates an initial state and side-effects |(common)","title":"oolong.Init"},{"location":"oolong/alltypes/#oolongnext","text":"A pair of the next state and side-effects |(common)","title":"oolong.Next"},{"location":"oolong/alltypes/#oolongoolong","text":"Oolong runtime module. |(common)","title":"oolong.Oolong"},{"location":"oolong/alltypes/#oolongrender","text":"Renders the view properties |(common)","title":"oolong.Render"},{"location":"oolong/alltypes/#oolongupdate","text":"Creates a next state and side-effects from a message and current state |(common)","title":"oolong.Update"},{"location":"oolong/alltypes/#oolongview","text":"Creates view properties from the current state","title":"oolong.View"},{"location":"oolong/oolong/","text":"oolong / oolong Package oolong Types Name Summary (common) Dispatch Dispatches a message to the runtime typealias Dispatch<Msg> = (msg: Msg) -> Unit (common) Dispose Stops the function and cleans up resources typealias Dispose = () -> Unit (common) Effect Runs a side-effect away from the runtime typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch <Msg>) -> Any ? (common) Init Creates an initial state and side-effects typealias Init<Model, Msg> = () -> Next <Model, Msg> (common) Next A pair of the next state and side-effects typealias Next<Model, Msg> = Pair <Model, Effect <Msg>> (common) Oolong Oolong runtime module. object Oolong (common) Render Renders the view properties typealias Render<Msg, Props> = (props: Props, dispatch: Dispatch <Msg>) -> Any ? (common) Update Creates a next state and side-effects from a message and current state typealias Update<Model, Msg> = (msg: Msg, model: Model) -> Next <Model, Msg> (common) View Creates view properties from the current state typealias View<Model, Props> = (model: Model) -> Props Functions Name Summary (common) effect Effect builder function. fun <Msg : Any > effect(block: Effect <Msg>): Effect <Msg> (common) init Init builder function. fun <Model : Any , Msg : Any > init(block: Init <Model, Msg>): Init <Model, Msg> (common) render Render builder function. fun <Props : Any , Msg : Any > render(block: Render <Props, Msg>): Render <Props, Msg> (common) update Update builder function. fun <Model : Any , Msg : Any > update(block: Update <Model, Msg>): Update <Model, Msg> (common) view View builder function. fun <Model : Any , Props : Any > view(block: View <Model, Props>): View <Model, Props>","title":"Package oolong - Oolong"},{"location":"oolong/oolong/#package-oolong","text":"","title":"Package oolong"},{"location":"oolong/oolong/#types","text":"Name Summary (common) Dispatch Dispatches a message to the runtime typealias Dispatch<Msg> = (msg: Msg) -> Unit (common) Dispose Stops the function and cleans up resources typealias Dispose = () -> Unit (common) Effect Runs a side-effect away from the runtime typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch <Msg>) -> Any ? (common) Init Creates an initial state and side-effects typealias Init<Model, Msg> = () -> Next <Model, Msg> (common) Next A pair of the next state and side-effects typealias Next<Model, Msg> = Pair <Model, Effect <Msg>> (common) Oolong Oolong runtime module. object Oolong (common) Render Renders the view properties typealias Render<Msg, Props> = (props: Props, dispatch: Dispatch <Msg>) -> Any ? (common) Update Creates a next state and side-effects from a message and current state typealias Update<Model, Msg> = (msg: Msg, model: Model) -> Next <Model, Msg> (common) View Creates view properties from the current state typealias View<Model, Props> = (model: Model) -> Props","title":"Types"},{"location":"oolong/oolong/#functions","text":"Name Summary (common) effect Effect builder function. fun <Msg : Any > effect(block: Effect <Msg>): Effect <Msg> (common) init Init builder function. fun <Model : Any , Msg : Any > init(block: Init <Model, Msg>): Init <Model, Msg> (common) render Render builder function. fun <Props : Any , Msg : Any > render(block: Render <Props, Msg>): Render <Props, Msg> (common) update Update builder function. fun <Model : Any , Msg : Any > update(block: Update <Model, Msg>): Update <Model, Msg> (common) view View builder function. fun <Model : Any , Props : Any > view(block: View <Model, Props>): View <Model, Props>","title":"Functions"},{"location":"oolong/oolong/-dispatch/","text":"oolong / oolong / Dispatch Dispatch (common) typealias Dispatch<Msg> = (msg: Msg) -> Unit (source) Dispatches a message to the runtime Parameters msg - the message to send","title":"Dispatch - Oolong"},{"location":"oolong/oolong/-dispatch/#dispatch","text":"(common) typealias Dispatch<Msg> = (msg: Msg) -> Unit (source) Dispatches a message to the runtime","title":"Dispatch"},{"location":"oolong/oolong/-dispatch/#parameters","text":"msg - the message to send","title":"Parameters"},{"location":"oolong/oolong/-dispose/","text":"oolong / oolong / Dispose Dispose (common) typealias Dispose = () -> Unit (source) Stops the function and cleans up resources","title":"Dispose - Oolong"},{"location":"oolong/oolong/-dispose/#dispose","text":"(common) typealias Dispose = () -> Unit (source) Stops the function and cleans up resources","title":"Dispose"},{"location":"oolong/oolong/-effect/","text":"oolong / oolong / Effect Effect (common) typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch <Msg>) -> Any ? (source) Runs a side-effect away from the runtime Parameters dispatch - the dispatch function","title":"Effect - Oolong"},{"location":"oolong/oolong/-effect/#effect","text":"(common) typealias Effect<Msg> = suspend CoroutineScope.(dispatch: Dispatch <Msg>) -> Any ? (source) Runs a side-effect away from the runtime","title":"Effect"},{"location":"oolong/oolong/-effect/#parameters","text":"dispatch - the dispatch function","title":"Parameters"},{"location":"oolong/oolong/-init/","text":"oolong / oolong / Init Init (common) typealias Init<Model, Msg> = () -> Next <Model, Msg> (source) Creates an initial state and side-effects","title":"Init - Oolong"},{"location":"oolong/oolong/-init/#init","text":"(common) typealias Init<Model, Msg> = () -> Next <Model, Msg> (source) Creates an initial state and side-effects","title":"Init"},{"location":"oolong/oolong/-next/","text":"oolong / oolong / Next Next (common) typealias Next<Model, Msg> = Pair <Model, Effect <Msg>> (source) A pair of the next state and side-effects","title":"Next - Oolong"},{"location":"oolong/oolong/-next/#next","text":"(common) typealias Next<Model, Msg> = Pair <Model, Effect <Msg>> (source) A pair of the next state and side-effects","title":"Next"},{"location":"oolong/oolong/-render/","text":"oolong / oolong / Render Render (common) typealias Render<Msg, Props> = (props: Props, dispatch: Dispatch <Msg>) -> Any ? (source) Renders the view properties Parameters props - view properties","title":"Render - Oolong"},{"location":"oolong/oolong/-render/#render","text":"(common) typealias Render<Msg, Props> = (props: Props, dispatch: Dispatch <Msg>) -> Any ? (source) Renders the view properties","title":"Render"},{"location":"oolong/oolong/-render/#parameters","text":"props - view properties","title":"Parameters"},{"location":"oolong/oolong/-update/","text":"oolong / oolong / Update Update (common) typealias Update<Model, Msg> = (msg: Msg, model: Model) -> Next <Model, Msg> (source) Creates a next state and side-effects from a message and current state Parameters msg - the message to interpret model - the current state","title":"Update - Oolong"},{"location":"oolong/oolong/-update/#update","text":"(common) typealias Update<Model, Msg> = (msg: Msg, model: Model) -> Next <Model, Msg> (source) Creates a next state and side-effects from a message and current state","title":"Update"},{"location":"oolong/oolong/-update/#parameters","text":"msg - the message to interpret model - the current state","title":"Parameters"},{"location":"oolong/oolong/-view/","text":"oolong / oolong / View View (common) typealias View<Model, Props> = (model: Model) -> Props (source) Creates view properties from the current state Parameters model - the current state dispatch - the dispatch function","title":"View - Oolong"},{"location":"oolong/oolong/-view/#view","text":"(common) typealias View<Model, Props> = (model: Model) -> Props (source) Creates view properties from the current state","title":"View"},{"location":"oolong/oolong/-view/#parameters","text":"model - the current state dispatch - the dispatch function","title":"Parameters"},{"location":"oolong/oolong/effect/","text":"oolong / oolong / effect effect (common) fun <Msg : Any > effect(block: Effect <Msg>): Effect <Msg> (source) Effect builder function.","title":"effect - Oolong"},{"location":"oolong/oolong/effect/#effect","text":"(common) fun <Msg : Any > effect(block: Effect <Msg>): Effect <Msg> (source) Effect builder function.","title":"effect"},{"location":"oolong/oolong/init/","text":"oolong / oolong / init init (common) fun <Model : Any , Msg : Any > init(block: Init <Model, Msg>): Init <Model, Msg> (source) Init builder function.","title":"init - Oolong"},{"location":"oolong/oolong/init/#init","text":"(common) fun <Model : Any , Msg : Any > init(block: Init <Model, Msg>): Init <Model, Msg> (source) Init builder function.","title":"init"},{"location":"oolong/oolong/render/","text":"oolong / oolong / render render (common) fun <Props : Any , Msg : Any > render(block: Render <Props, Msg>): Render <Props, Msg> (source) Render builder function.","title":"render - Oolong"},{"location":"oolong/oolong/render/#render","text":"(common) fun <Props : Any , Msg : Any > render(block: Render <Props, Msg>): Render <Props, Msg> (source) Render builder function.","title":"render"},{"location":"oolong/oolong/update/","text":"oolong / oolong / update update (common) fun <Model : Any , Msg : Any > update(block: Update <Model, Msg>): Update <Model, Msg> (source) Update builder function.","title":"update - Oolong"},{"location":"oolong/oolong/update/#update","text":"(common) fun <Model : Any , Msg : Any > update(block: Update <Model, Msg>): Update <Model, Msg> (source) Update builder function.","title":"update"},{"location":"oolong/oolong/view/","text":"oolong / oolong / view view (common) fun <Model : Any , Props : Any > view(block: View <Model, Props>): View <Model, Props> (source) View builder function.","title":"view - Oolong"},{"location":"oolong/oolong/view/#view","text":"(common) fun <Model : Any , Props : Any > view(block: View <Model, Props>): View <Model, Props> (source) View builder function.","title":"view"},{"location":"oolong/oolong/-oolong/","text":"oolong / oolong / Oolong Oolong (common) object Oolong (source) Oolong runtime module. Functions Name Summary (common) runtime Create a runtime. fun <Model : Any , Msg : Any , Props : Any > runtime(init: Init <Model, Msg>, update: Update <Model, Msg>, view: View <Model, Props>, render: Render <Msg, Props>, runtimeDispatcher: CoroutineDispatcher = Dispatchers.Default, renderDispatcher: CoroutineDispatcher = Dispatchers.Main, effectDispatcher: CoroutineDispatcher = Dispatchers.Default): Dispose","title":"Oolong - Oolong"},{"location":"oolong/oolong/-oolong/#oolong","text":"(common) object Oolong (source) Oolong runtime module.","title":"Oolong"},{"location":"oolong/oolong/-oolong/#functions","text":"Name Summary (common) runtime Create a runtime. fun <Model : Any , Msg : Any , Props : Any > runtime(init: Init <Model, Msg>, update: Update <Model, Msg>, view: View <Model, Props>, render: Render <Msg, Props>, runtimeDispatcher: CoroutineDispatcher = Dispatchers.Default, renderDispatcher: CoroutineDispatcher = Dispatchers.Main, effectDispatcher: CoroutineDispatcher = Dispatchers.Default): Dispose","title":"Functions"},{"location":"oolong/oolong/-oolong/runtime/","text":"oolong / oolong / Oolong / runtime runtime (common) @JvmOverloads fun <Model : Any , Msg : Any , Props : Any > runtime(init: Init <Model, Msg>, update: Update <Model, Msg>, view: View <Model, Props>, render: Render <Msg, Props>, runtimeDispatcher: CoroutineDispatcher = Dispatchers.Default, renderDispatcher: CoroutineDispatcher = Dispatchers.Main, effectDispatcher: CoroutineDispatcher = Dispatchers.Default): Dispose (source) Create a runtime.","title":"runtime - Oolong"},{"location":"oolong/oolong/-oolong/runtime/#runtime","text":"(common) @JvmOverloads fun <Model : Any , Msg : Any , Props : Any > runtime(init: Init <Model, Msg>, update: Update <Model, Msg>, view: View <Model, Props>, render: Render <Msg, Props>, runtimeDispatcher: CoroutineDispatcher = Dispatchers.Default, renderDispatcher: CoroutineDispatcher = Dispatchers.Main, effectDispatcher: CoroutineDispatcher = Dispatchers.Default): Dispose (source) Create a runtime.","title":"runtime"},{"location":"oolong/oolong.delay/","text":"oolong / oolong.delay Package oolong.delay Functions Name Summary (common) delay Generate a Msg after a specified timeMillis. fun <Msg : Any > delay(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (common) interval Generate Msg s at a specified timeMillis. fun <Msg : Any > interval(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg>","title":"Package oolong.delay - Oolong"},{"location":"oolong/oolong.delay/#package-oolongdelay","text":"","title":"Package oolong.delay"},{"location":"oolong/oolong.delay/#functions","text":"Name Summary (common) delay Generate a Msg after a specified timeMillis. fun <Msg : Any > delay(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (common) interval Generate Msg s at a specified timeMillis. fun <Msg : Any > interval(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg>","title":"Functions"},{"location":"oolong/oolong.delay/delay/","text":"oolong / oolong.delay / delay delay (common) fun <Msg : Any > delay(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (source) Generate a Msg after a specified timeMillis. Parameters timeMillis - time in milliseconds. msg - generator function of Msg Return a delayed effect","title":"delay - Oolong"},{"location":"oolong/oolong.delay/delay/#delay","text":"(common) fun <Msg : Any > delay(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (source) Generate a Msg after a specified timeMillis.","title":"delay"},{"location":"oolong/oolong.delay/delay/#parameters","text":"timeMillis - time in milliseconds. msg - generator function of Msg Return a delayed effect","title":"Parameters"},{"location":"oolong/oolong.delay/interval/","text":"oolong / oolong.delay / interval interval (common) fun <Msg : Any > interval(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (source) Generate Msg s at a specified timeMillis. Parameters timeMillis - time in milliseconds. msg - generator function of Msg Return a delayed effect","title":"interval - Oolong"},{"location":"oolong/oolong.delay/interval/#interval","text":"(common) fun <Msg : Any > interval(timeMillis: Long , msg: suspend CoroutineScope.() -> Msg): Effect <Msg> (source) Generate Msg s at a specified timeMillis.","title":"interval"},{"location":"oolong/oolong.delay/interval/#parameters","text":"timeMillis - time in milliseconds. msg - generator function of Msg Return a delayed effect","title":"Parameters"},{"location":"oolong/oolong.dispatch/","text":"oolong / oolong.dispatch Package oolong.dispatch Functions Name Summary (common) contramap Contramap from Dispatch of A to Dispatch of B fun <A : Any , B : Any > contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B>","title":"Package oolong.dispatch - Oolong"},{"location":"oolong/oolong.dispatch/#package-oolongdispatch","text":"","title":"Package oolong.dispatch"},{"location":"oolong/oolong.dispatch/#functions","text":"Name Summary (common) contramap Contramap from Dispatch of A to Dispatch of B fun <A : Any , B : Any > contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B>","title":"Functions"},{"location":"oolong/oolong.dispatch/contramap/","text":"oolong / oolong.dispatch / contramap contramap (common) fun <A : Any , B : Any > contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B> (source) Contramap from Dispatch of A to Dispatch of B contramap can be used to map a dispatch function from a parent Msg to a child Msg . A typical use for contramap is compositional screen management. Example: sealed class Props { data class Home ( val props : HomeProps ): Props () data class Settings ( val props : SettingsProps ): Props () } sealed class Msg { data class Home ( val msg : HomeMsg ) : Msg () data class Settings ( val msg : SettingsMsg ) : Msg () } val render : Render < Msg , Props > = { props : Props , dispatch : Dispatch < Msg > -> when ( props ) { is Props . Home -> { homeRender ( props . props , contramap ( dispatch , Msg :: Home )) } is Props . Settings -> { settingsRender ( props . props , contramap ( dispatch , Msg :: Settings )) } } }","title":"contramap - Oolong"},{"location":"oolong/oolong.dispatch/contramap/#contramap","text":"(common) fun <A : Any , B : Any > contramap(dispatch: Dispatch <A>, f: (B) -> A): Dispatch <B> (source) Contramap from Dispatch of A to Dispatch of B contramap can be used to map a dispatch function from a parent Msg to a child Msg . A typical use for contramap is compositional screen management. Example: sealed class Props { data class Home ( val props : HomeProps ): Props () data class Settings ( val props : SettingsProps ): Props () } sealed class Msg { data class Home ( val msg : HomeMsg ) : Msg () data class Settings ( val msg : SettingsMsg ) : Msg () } val render : Render < Msg , Props > = { props : Props , dispatch : Dispatch < Msg > -> when ( props ) { is Props . Home -> { homeRender ( props . props , contramap ( dispatch , Msg :: Home )) } is Props . Settings -> { settingsRender ( props . props , contramap ( dispatch , Msg :: Settings )) } } }","title":"contramap"},{"location":"oolong/oolong.effect/","text":"oolong / oolong.effect Package oolong.effect Functions Name Summary (common) batch Compose a collection of Effect into a single Effect . fun <Msg : Any > batch(vararg effects: Effect <Msg>): Effect <Msg> fun <Msg : Any > batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (common) disposableEffect Create a Pair of Effect and Dispose . fun <Msg : Any > disposableEffect(effect: Effect <Msg>): Pair < Effect <Msg>, Dispose > (common) map Map from Effect of A to Effect of B fun <A : Any , B : Any > map(effect: Effect <A>, f: (A) -> B): Effect <B> (common) none Create an empty Effect . fun <Msg : Any > none(): Effect <Msg>","title":"Package oolong.effect - Oolong"},{"location":"oolong/oolong.effect/#package-oolongeffect","text":"","title":"Package oolong.effect"},{"location":"oolong/oolong.effect/#functions","text":"Name Summary (common) batch Compose a collection of Effect into a single Effect . fun <Msg : Any > batch(vararg effects: Effect <Msg>): Effect <Msg> fun <Msg : Any > batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (common) disposableEffect Create a Pair of Effect and Dispose . fun <Msg : Any > disposableEffect(effect: Effect <Msg>): Pair < Effect <Msg>, Dispose > (common) map Map from Effect of A to Effect of B fun <A : Any , B : Any > map(effect: Effect <A>, f: (A) -> B): Effect <B> (common) none Create an empty Effect . fun <Msg : Any > none(): Effect <Msg>","title":"Functions"},{"location":"oolong/oolong.effect/batch/","text":"oolong / oolong.effect / batch batch (common) fun <Msg : Any > batch(vararg effects: Effect <Msg>): Effect <Msg> (source) fun <Msg : Any > batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (source) Compose a collection of Effect into a single Effect . Parameters effects - a list of effects","title":"batch - Oolong"},{"location":"oolong/oolong.effect/batch/#batch","text":"(common) fun <Msg : Any > batch(vararg effects: Effect <Msg>): Effect <Msg> (source) fun <Msg : Any > batch(effects: Iterable < Effect <Msg>>): Effect <Msg> (source) Compose a collection of Effect into a single Effect .","title":"batch"},{"location":"oolong/oolong.effect/batch/#parameters","text":"effects - a list of effects","title":"Parameters"},{"location":"oolong/oolong.effect/disposable-effect/","text":"oolong / oolong.effect / disposableEffect disposableEffect (common) fun <Msg : Any > disposableEffect(effect: Effect <Msg>): Pair < Effect <Msg>, Dispose > (source) Create a Pair of Effect and Dispose .","title":"disposableEffect - Oolong"},{"location":"oolong/oolong.effect/disposable-effect/#disposableeffect","text":"(common) fun <Msg : Any > disposableEffect(effect: Effect <Msg>): Pair < Effect <Msg>, Dispose > (source) Create a Pair of Effect and Dispose .","title":"disposableEffect"},{"location":"oolong/oolong.effect/map/","text":"oolong / oolong.effect / map map (common) fun <A : Any , B : Any > map(effect: Effect <A>, f: (A) -> B): Effect <B> (source) Map from Effect of A to Effect of B","title":"map - Oolong"},{"location":"oolong/oolong.effect/map/#map","text":"(common) fun <A : Any , B : Any > map(effect: Effect <A>, f: (A) -> B): Effect <B> (source) Map from Effect of A to Effect of B","title":"map"},{"location":"oolong/oolong.effect/none/","text":"oolong / oolong.effect / none none (common) fun <Msg : Any > none(): Effect <Msg> (source) Create an empty Effect .","title":"none - Oolong"},{"location":"oolong/oolong.effect/none/#none","text":"(common) fun <Msg : Any > none(): Effect <Msg> (source) Create an empty Effect .","title":"none"},{"location":"oolong/oolong.next/","text":"oolong / oolong.next Package oolong.next Functions Name Summary (common) bimap Map from Next of A and B to Next of C and D fun <A : Any , B : Any , C : Any , D : Any > bimap(next: Next <A, B>, fa: (A) -> C, fb: (B) -> D): Next <C, D>","title":"Package oolong.next - Oolong"},{"location":"oolong/oolong.next/#package-oolongnext","text":"","title":"Package oolong.next"},{"location":"oolong/oolong.next/#functions","text":"Name Summary (common) bimap Map from Next of A and B to Next of C and D fun <A : Any , B : Any , C : Any , D : Any > bimap(next: Next <A, B>, fa: (A) -> C, fb: (B) -> D): Next <C, D>","title":"Functions"},{"location":"oolong/oolong.next/bimap/","text":"oolong / oolong.next / bimap bimap (common) fun <A : Any , B : Any , C : Any , D : Any > bimap(next: Next <A, B>, fa: (A) -> C, fb: (B) -> D): Next <C, D> (source) Map from Next of A and B to Next of C and D bimap can be used to map an init or update function from a child Next to a parent Next . A typical use for bimap is compositional screen management. Example: sealed class Model { data class Home ( val model : HomeModel ): Model () data class Settings ( val model : SettingsModel ): Model () } sealed class Msg { data class Home ( val msg : HomeMsg ) : Msg () data class Settings ( val msg : SettingsMsg ) : Msg () } val update : Update < Model , Msg > = { msg : Msg , model : Model -> when ( msg ) { is Msg . Home -> { when ( model ) { is Model . Home -> bimap ( homeUpdate ( msg . msg , model . model ), Model :: Home , Msg :: Home ) else -> model to none () } } is Msg . Settings -> { when ( model ) { is Model . Settings -> bimap ( settingsUpdate ( msg . msg , model . model ), Model :: Settings , Msg :: Settings ) else -> model to none () } } } }","title":"bimap - Oolong"},{"location":"oolong/oolong.next/bimap/#bimap","text":"(common) fun <A : Any , B : Any , C : Any , D : Any > bimap(next: Next <A, B>, fa: (A) -> C, fb: (B) -> D): Next <C, D> (source) Map from Next of A and B to Next of C and D bimap can be used to map an init or update function from a child Next to a parent Next . A typical use for bimap is compositional screen management. Example: sealed class Model { data class Home ( val model : HomeModel ): Model () data class Settings ( val model : SettingsModel ): Model () } sealed class Msg { data class Home ( val msg : HomeMsg ) : Msg () data class Settings ( val msg : SettingsMsg ) : Msg () } val update : Update < Model , Msg > = { msg : Msg , model : Model -> when ( msg ) { is Msg . Home -> { when ( model ) { is Model . Home -> bimap ( homeUpdate ( msg . msg , model . model ), Model :: Home , Msg :: Home ) else -> model to none () } } is Msg . Settings -> { when ( model ) { is Model . Settings -> bimap ( settingsUpdate ( msg . msg , model . model ), Model :: Settings , Msg :: Settings ) else -> model to none () } } } }","title":"bimap"},{"location":"oolong/oolong.random/","text":"oolong / oolong.random Package oolong.random Functions Name Summary (common) nextBits Call Random.nextBits with a mapping of Int to Msg . fun <Msg : Any > nextBits(bitCount: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (common) nextBoolean Call Random.nextBoolean with a mapping of Boolean to Msg . fun <Msg : Any > nextBoolean(msg: suspend CoroutineScope.( Boolean ) -> Msg): Effect <Msg> (common) nextBytes Call Random.nextBytes with a mapping of ByteArray to Msg . fun <Msg : Any > nextBytes(array: ByteArray , fromIndex: Int , toIndex: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextBytes(array: ByteArray , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextBytes(size: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (common) nextDouble Call Random.nextDouble with a mapping of Double to Msg . fun <Msg : Any > nextDouble(msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> fun <Msg : Any > nextDouble(until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> fun <Msg : Any > nextDouble(from: Double , until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (common) nextFloat Call Random.nextFloat with a mapping of Float to Msg . fun <Msg : Any > nextFloat(msg: suspend CoroutineScope.( Float ) -> Msg): Effect <Msg> (common) nextInt Call Random.nextInt with a mapping of Int to Msg . fun <Msg : Any > nextInt(msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(from: Int , until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(range: IntRange , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (common) nextLong Call Random.nextLong with a mapping of Long to Msg . fun <Msg : Any > nextLong(msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(from: Long , until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(range: LongRange , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (common) nextUBytes Call Random.nextUBytes with a mapping of UByteArray to Msg . fun <Msg : Any > nextUBytes(array: UByteArray , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextUBytes(size: Int , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (common) nextUInt Call Random.nextUInt with a mapping of UInt to Msg . fun <Msg : Any > nextUInt(msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(from: UInt , until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(range: UIntRange , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (common) nextULong Call Random.nextULong with a mapping of ULong to Msg . fun <Msg : Any > nextULong(msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(from: ULong , until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(range: ULongRange , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg>","title":"Package oolong.random - Oolong"},{"location":"oolong/oolong.random/#package-oolongrandom","text":"","title":"Package oolong.random"},{"location":"oolong/oolong.random/#functions","text":"Name Summary (common) nextBits Call Random.nextBits with a mapping of Int to Msg . fun <Msg : Any > nextBits(bitCount: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (common) nextBoolean Call Random.nextBoolean with a mapping of Boolean to Msg . fun <Msg : Any > nextBoolean(msg: suspend CoroutineScope.( Boolean ) -> Msg): Effect <Msg> (common) nextBytes Call Random.nextBytes with a mapping of ByteArray to Msg . fun <Msg : Any > nextBytes(array: ByteArray , fromIndex: Int , toIndex: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextBytes(array: ByteArray , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextBytes(size: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (common) nextDouble Call Random.nextDouble with a mapping of Double to Msg . fun <Msg : Any > nextDouble(msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> fun <Msg : Any > nextDouble(until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> fun <Msg : Any > nextDouble(from: Double , until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (common) nextFloat Call Random.nextFloat with a mapping of Float to Msg . fun <Msg : Any > nextFloat(msg: suspend CoroutineScope.( Float ) -> Msg): Effect <Msg> (common) nextInt Call Random.nextInt with a mapping of Int to Msg . fun <Msg : Any > nextInt(msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(from: Int , until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> fun <Msg : Any > nextInt(range: IntRange , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (common) nextLong Call Random.nextLong with a mapping of Long to Msg . fun <Msg : Any > nextLong(msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(from: Long , until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> fun <Msg : Any > nextLong(range: LongRange , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (common) nextUBytes Call Random.nextUBytes with a mapping of UByteArray to Msg . fun <Msg : Any > nextUBytes(array: UByteArray , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> fun <Msg : Any > nextUBytes(size: Int , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (common) nextUInt Call Random.nextUInt with a mapping of UInt to Msg . fun <Msg : Any > nextUInt(msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(from: UInt , until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> fun <Msg : Any > nextUInt(range: UIntRange , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (common) nextULong Call Random.nextULong with a mapping of ULong to Msg . fun <Msg : Any > nextULong(msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(from: ULong , until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> fun <Msg : Any > nextULong(range: ULongRange , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg>","title":"Functions"},{"location":"oolong/oolong.random/next-bits/","text":"oolong / oolong.random / nextBits nextBits (common) fun <Msg : Any > nextBits(bitCount: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) Call Random.nextBits with a mapping of Int to Msg . Parameters msg - map function of Int to Msg Return Effect of Msg for the generated Int","title":"nextBits - Oolong"},{"location":"oolong/oolong.random/next-bits/#nextbits","text":"(common) fun <Msg : Any > nextBits(bitCount: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) Call Random.nextBits with a mapping of Int to Msg .","title":"nextBits"},{"location":"oolong/oolong.random/next-bits/#parameters","text":"msg - map function of Int to Msg Return Effect of Msg for the generated Int","title":"Parameters"},{"location":"oolong/oolong.random/next-boolean/","text":"oolong / oolong.random / nextBoolean nextBoolean (common) fun <Msg : Any > nextBoolean(msg: suspend CoroutineScope.( Boolean ) -> Msg): Effect <Msg> (source) Call Random.nextBoolean with a mapping of Boolean to Msg . Parameters msg - map function of Boolean to Msg Return Effect of Msg for the generated Boolean","title":"nextBoolean - Oolong"},{"location":"oolong/oolong.random/next-boolean/#nextboolean","text":"(common) fun <Msg : Any > nextBoolean(msg: suspend CoroutineScope.( Boolean ) -> Msg): Effect <Msg> (source) Call Random.nextBoolean with a mapping of Boolean to Msg .","title":"nextBoolean"},{"location":"oolong/oolong.random/next-boolean/#parameters","text":"msg - map function of Boolean to Msg Return Effect of Msg for the generated Boolean","title":"Parameters"},{"location":"oolong/oolong.random/next-bytes/","text":"oolong / oolong.random / nextBytes nextBytes (common) fun <Msg : Any > nextBytes(array: ByteArray , fromIndex: Int , toIndex: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextBytes(array: ByteArray , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextBytes(size: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) Call Random.nextBytes with a mapping of ByteArray to Msg . Parameters msg - map function of ByteArray to Msg Return Effect of Msg for the generated ByteArray","title":"nextBytes - Oolong"},{"location":"oolong/oolong.random/next-bytes/#nextbytes","text":"(common) fun <Msg : Any > nextBytes(array: ByteArray , fromIndex: Int , toIndex: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextBytes(array: ByteArray , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextBytes(size: Int , msg: suspend CoroutineScope.( ByteArray ) -> Msg): Effect <Msg> (source) Call Random.nextBytes with a mapping of ByteArray to Msg .","title":"nextBytes"},{"location":"oolong/oolong.random/next-bytes/#parameters","text":"msg - map function of ByteArray to Msg Return Effect of Msg for the generated ByteArray","title":"Parameters"},{"location":"oolong/oolong.random/next-double/","text":"oolong / oolong.random / nextDouble nextDouble (common) fun <Msg : Any > nextDouble(msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextDouble(until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextDouble(from: Double , until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) Call Random.nextDouble with a mapping of Double to Msg . Parameters msg - map function of Double to Msg Return Effect of Msg for the generated Double","title":"nextDouble - Oolong"},{"location":"oolong/oolong.random/next-double/#nextdouble","text":"(common) fun <Msg : Any > nextDouble(msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextDouble(until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextDouble(from: Double , until: Double , msg: suspend CoroutineScope.( Double ) -> Msg): Effect <Msg> (source) Call Random.nextDouble with a mapping of Double to Msg .","title":"nextDouble"},{"location":"oolong/oolong.random/next-double/#parameters","text":"msg - map function of Double to Msg Return Effect of Msg for the generated Double","title":"Parameters"},{"location":"oolong/oolong.random/next-float/","text":"oolong / oolong.random / nextFloat nextFloat (common) fun <Msg : Any > nextFloat(msg: suspend CoroutineScope.( Float ) -> Msg): Effect <Msg> (source) Call Random.nextFloat with a mapping of Float to Msg . Parameters msg - map function of Float to Msg Return Effect of Msg for the generated Float","title":"nextFloat - Oolong"},{"location":"oolong/oolong.random/next-float/#nextfloat","text":"(common) fun <Msg : Any > nextFloat(msg: suspend CoroutineScope.( Float ) -> Msg): Effect <Msg> (source) Call Random.nextFloat with a mapping of Float to Msg .","title":"nextFloat"},{"location":"oolong/oolong.random/next-float/#parameters","text":"msg - map function of Float to Msg Return Effect of Msg for the generated Float","title":"Parameters"},{"location":"oolong/oolong.random/next-int/","text":"oolong / oolong.random / nextInt nextInt (common) fun <Msg : Any > nextInt(msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(from: Int , until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(range: IntRange , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) Call Random.nextInt with a mapping of Int to Msg . Parameters msg - map function of Int to Msg Return Effect of Msg for the generated Int","title":"nextInt - Oolong"},{"location":"oolong/oolong.random/next-int/#nextint","text":"(common) fun <Msg : Any > nextInt(msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(from: Int , until: Int , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextInt(range: IntRange , msg: suspend CoroutineScope.( Int ) -> Msg): Effect <Msg> (source) Call Random.nextInt with a mapping of Int to Msg .","title":"nextInt"},{"location":"oolong/oolong.random/next-int/#parameters","text":"msg - map function of Int to Msg Return Effect of Msg for the generated Int","title":"Parameters"},{"location":"oolong/oolong.random/next-long/","text":"oolong / oolong.random / nextLong nextLong (common) fun <Msg : Any > nextLong(msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(from: Long , until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(range: LongRange , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) Call Random.nextLong with a mapping of Long to Msg . Parameters msg - map function of Long to Msg Return Effect of Msg for the generated Long","title":"nextLong - Oolong"},{"location":"oolong/oolong.random/next-long/#nextlong","text":"(common) fun <Msg : Any > nextLong(msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(from: Long , until: Long , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) fun <Msg : Any > nextLong(range: LongRange , msg: suspend CoroutineScope.( Long ) -> Msg): Effect <Msg> (source) Call Random.nextLong with a mapping of Long to Msg .","title":"nextLong"},{"location":"oolong/oolong.random/next-long/#parameters","text":"msg - map function of Long to Msg Return Effect of Msg for the generated Long","title":"Parameters"},{"location":"oolong/oolong.random/next-u-bytes/","text":"oolong / oolong.random / nextUBytes nextUBytes (common) @ExperimentalUnsignedTypes fun <Msg : Any > nextUBytes(array: UByteArray , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUBytes(size: Int , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (source) Call Random.nextUBytes with a mapping of UByteArray to Msg . Parameters msg - map function of UByteArray to Msg Return Effect of Msg for the generated UByteArray","title":"nextUBytes - Oolong"},{"location":"oolong/oolong.random/next-u-bytes/#nextubytes","text":"(common) @ExperimentalUnsignedTypes fun <Msg : Any > nextUBytes(array: UByteArray , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUBytes(size: Int , msg: suspend CoroutineScope.( UByteArray ) -> Msg): Effect <Msg> (source) Call Random.nextUBytes with a mapping of UByteArray to Msg .","title":"nextUBytes"},{"location":"oolong/oolong.random/next-u-bytes/#parameters","text":"msg - map function of UByteArray to Msg Return Effect of Msg for the generated UByteArray","title":"Parameters"},{"location":"oolong/oolong.random/next-u-int/","text":"oolong / oolong.random / nextUInt nextUInt (common) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(from: UInt , until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(range: UIntRange , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) Call Random.nextUInt with a mapping of UInt to Msg . Parameters msg - map function of UInt to Msg Return Effect of Msg for the generated UInt","title":"nextUInt - Oolong"},{"location":"oolong/oolong.random/next-u-int/#nextuint","text":"(common) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(from: UInt , until: UInt , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextUInt(range: UIntRange , msg: suspend CoroutineScope.( UInt ) -> Msg): Effect <Msg> (source) Call Random.nextUInt with a mapping of UInt to Msg .","title":"nextUInt"},{"location":"oolong/oolong.random/next-u-int/#parameters","text":"msg - map function of UInt to Msg Return Effect of Msg for the generated UInt","title":"Parameters"},{"location":"oolong/oolong.random/next-u-long/","text":"oolong / oolong.random / nextULong nextULong (common) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(from: ULong , until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(range: ULongRange , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) Call Random.nextULong with a mapping of ULong to Msg . Parameters msg - map function of ULong to Msg Return Effect of Msg for the generated ULong","title":"nextULong - Oolong"},{"location":"oolong/oolong.random/next-u-long/#nextulong","text":"(common) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(from: ULong , until: ULong , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) @ExperimentalUnsignedTypes fun <Msg : Any > nextULong(range: ULongRange , msg: suspend CoroutineScope.( ULong ) -> Msg): Effect <Msg> (source) Call Random.nextULong with a mapping of ULong to Msg .","title":"nextULong"},{"location":"oolong/oolong.random/next-u-long/#parameters","text":"msg - map function of ULong to Msg Return Effect of Msg for the generated ULong","title":"Parameters"},{"location":"recipes/isolation/","text":"Isolation Coming soon!","title":"Isolation"},{"location":"recipes/isolation/#isolation","text":"Coming soon!","title":"Isolation"},{"location":"recipes/navigation/","text":"Navigation Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail . Data Structures The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model is comprised of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Next < Model , Msg >): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () } Functions Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Next<A, B> to an instance of Next<C, D> . We're goint to use List as our initial screen, so in this case we're bimapping from an instance of Next<List.Model, List.Msg> to an instance of Next<Model, Msg> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : Init < Model , Msg > = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : Update < Model , Msg > = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : View < Model , Props > = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : Render < Msg , Props > = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } } Navigating With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigation"},{"location":"recipes/navigation/#navigation","text":"Since MVU architecture is fractal and composable, navigation is simply an excercise in composition and delegation. Let's look at a simple example with two screens: List and Detail .","title":"Navigation"},{"location":"recipes/navigation/#data-structures","text":"The navigation component needs to have an awareness of the logical screens in order to delegate to them, so we must create Model , Msg , and Props wrappers for each screen. A navigation component's model is comprised of wrapper instances for each screen: sealed class Model { // Delegates data class List ( model : List . Model ) : Model () data class Detail ( model : Detail . Model ) : Model () } Similarly, delegated components also need wrappers for their message types. Additionally, we have defined a navigation message to set a new screen. sealed class Msg { // Delegates data class List ( msg : List . Msg ) : Msg () data class Detail ( msg : Detail . Msg ) : Msg () // Navigation data class SetScreen ( next : Next < Model , Msg >): Msg () } Finally, we create delegation wrappers for each screen's props. sealed class Props { // Delegates data class List ( props : List . Props ) : Props () data class Detail ( props : Detail . Props ) : Props () }","title":"Data Structures"},{"location":"recipes/navigation/#functions","text":"Now that the appropriate types have been defined, we can define program functions which delegate to each screen. Let's look each function in order starting with init . Oolong provides a few utility functions for common use-cases and one of these is bimap . The bimap function transforms an instance of Next<A, B> to an instance of Next<C, D> . We're goint to use List as our initial screen, so in this case we're bimapping from an instance of Next<List.Model, List.Msg> to an instance of Next<Model, Msg> . In other words, we're taking the List.Model and List.Msg returned from List.init and wrapping them in the delegated types of Model.List and Msg.List . val init : Init < Model , Msg > = { bimap ( List . init (), Model :: List , Msg :: List ) } The same bimap function is used to delegate to screens in the update function. If the msg is an instance of a screen message wrapper, then we delegate to that screen using bimap . However, we receive a SetScreen message, we simply return the next value provided. val update : Update < Model , Msg > = { msg , model -> when ( msg ) { is Msg . List -> { bimap ( List . update ( msg . msg , ( model as Model . List ). model ), Model :: List , Msg :: List ) } is Msg . Detail -> { bimap ( Detail . update ( msg . msg , ( model as Model . Detail ). model ), Model :: Detail , Msg :: Detail ) } is Msg . SetScreen -> { msg . next } } } The view function is quite simple, as we only need to wrap the screen's props with it's respected instance in the navigation props. val view : View < Model , Props > = { model -> when ( model ) { is Model . List -> { Props . List ( List . view ( model . model )) } is Model . Detail -> { Props . Detail ( Detail . view ( model . model )) } } } Finally, in the view function we unwrap the props and delegate to each screen's render function. There is one additional consideration we need to take in this function, however, which is mapping the dispatch function from the screen's Msg type to the parent's. For this, we can use the provided contramap fuction. val render : Render < Msg , Props > = { props , dispatch -> when ( props ) { is Props . List -> { List . render ( props . props , contramap ( dispatch , Msg :: List )) } is Props . Detail -> { Detail . render ( props . props , contramap ( dispatch , Msg :: Detail )) } } }","title":"Functions"},{"location":"recipes/navigation/#navigating","text":"With our types and functions setup for the navigation component, changing screens is done by simply dispatching a SetScreen message with the initial state for that screen. How navigation is performed and dispatched is an excercise for the user on each platform. Typically, you will create an adapter for your backstack which dispatches SetScreen using the latest instance of dispatch . val navigateToItemDetail = { id : Long , dispatch : Dispatch < Msg > -> val init = Detail . makeInit ( id ) val next = bimap ( init (), Model :: Detail , Msg :: Detail ) dispatch ( Msg . SetScreen ( next )) }","title":"Navigating"},{"location":"samples/official/","text":"Counter A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter Random A random number generator demonstrating Update effects. https://github.com/oolong-kt/samples/tree/master/samples/random Time A time display demonstrating Init effects. https://github.com/oolong-kt/samples/tree/master/samples/time TodoMVC An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"Official"},{"location":"samples/official/#counter","text":"A counter app demonstrating simple Msg updates. https://github.com/oolong-kt/samples/tree/master/samples/counter","title":"Counter"},{"location":"samples/official/#random","text":"A random number generator demonstrating Update effects. https://github.com/oolong-kt/samples/tree/master/samples/random","title":"Random"},{"location":"samples/official/#time","text":"A time display demonstrating Init effects. https://github.com/oolong-kt/samples/tree/master/samples/time","title":"Time"},{"location":"samples/official/#todomvc","text":"An implementation of TodoMVC https://github.com/oolong-kt/samples/tree/master/samples/todomvc","title":"TodoMVC"},{"location":"samples/third-party/","text":"Lambda news A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news Dice A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Third-party"},{"location":"samples/third-party/#lambda-news","text":"A functional HackerNews client for Kotlin Multiplatform. https://github.com/pardom/lambda-news","title":"Lambda news"},{"location":"samples/third-party/#dice","text":"A simple dice rolling app demonstrating a multiplatform functional architecture, with frontends for Android and iOS. https://github.com/pardom/dice","title":"Dice"}]}